'use strict'

import middy from 'middy'
import dynamoDocumentClient from '@util/aws/functions/dynamodb-document-client'
import * as middleware from '@util/middleware'
import log from '@util/log'
import query from '@util/aws/functions/query'
import { signals, roles } from '@util/signals'

/**
 * Handle an incoming WebSocket connection and update the dynamoDB database with pertinent information.
 * The handling of a request will be different depending on whether the given query parameter @role
 * is "initiator" or "receiver".
 * The initial connection request must have the following query parameters
 * or the client will not be able to attempt a connection:
 *
 * @param  {String} role - "initiator" or "receiver"
 * @param  {String} connId - Last 32 characters of the public key portion of the key-pair
 *                           created for the particular paired connection
 * @param  {String} signed - Private key signed with the private key created for the connection
 */
const handler = middy(async (event, context) => {
  const connectionId = event.requestContext.connectionId
  const query = event.queryStringParameters || {}
  const role = query.role || null
  const connectionData = {
    connectionId,
    query,
    event
  }

  switch (role) {
    case roles.initiator:
      return await handleInitiator(connectionData)
    case roles.receiver:
      return await handleReceiver(connectionData)
  }
}).use(middleware.validateConnectionParameters())

/**
 * Create a connection entry with initiator details. After successful creation of the entry,
 * connect the initiator client via the "ondbentry" function.
 *
 * @param  {Object} connectionData - Initial connection/handshake data provided by the initiator
 * @param  {String} connectionData.connectionId - The original connectionId provided/generated by AWS
 * @param  {Object} connectionData.event - Original connection event payload from AWS
 * @param  {String} connectionData.query - The handshake/query params provided by the initiator
 * @param  {String} connectionData.query.connId - The client-supplied connection string generated and supplied by the initiator.
 * @param  {String} connectionData.query.signed - The private key signed with the private key generated and supplied by the initiator.
 */
const handleInitiator = async connectionData => {
  log.info('Attempting to connect Initiator...', { connectionData })

  // Ensure an entry with given @connId does not already exist //
  let entries = await query.byConnId(connectionData.query.connId)
  if (entries.length > 0) {
    log.warn('Failed to connect: @connId already exists!', {
      connectionData,
      entries
    })
    return {
      statusCode: 500,
      body: `Failed to connect: @connId already exists!`
    }
  }

  const putParams = {
    connectionId: connectionData.connectionId,
    connId: connectionData.query.connId,
    role: roles.initiator,
    signed: connectionData.query.signed,
    endpoint:
      connectionData.event.requestContext.domainName +
      '/' +
      connectionData.event.requestContext.stage
  }

  try {
    const res = await dynamoDocumentClient.put(putParams)
    log.info('Successfully connected Initiator')
    return { statusCode: 200, body: `Connected` }
  } catch (e) {
    log.warn('Failed to connect Initiator', { e, putParams })
    return { statusCode: 500, body: `Failed to connect: ${JSON.stringify(e)}` }
  }
}

/**
 * Search for a matching db entry that should have been previously provided/created
 * by the initiator. Ensure that the @signed provided by the initiator and receiver match,
 * so that they can be securely paired. If so, create a DB entry for the receiver and connect them
 * via the "ondbentry" function.
 *
 * @param  {Object} connectionData - Initial connection/handshake data provided by the receiver
 * @param  {String} connectionData.connectionId - The original connectionId provided/generated by AWS
 * @param  {Object} connectionData.event - Original connection event payload from AWS
 * @param  {String} connectionData.query - The handshake/query params provided by the receiver
 * @param  {String} connectionData.query.connId - The client-supplied connection string originally generated and supplied
 *                                                by the initiator.
 * @param  {String} connectionData.query.signed - The private key signed with the private key originally generated and supplied
 *                                                by the initiator.
 */
const handleReceiver = async connectionData => {
  log.info('Attempting to connect Receiver...', { connectionData })

  // Ensure that an initiator exists, and a receiver does not //
  let entries = await query.byConnId(connectionData.query.connId)
  if (entries.length === 0) {
    log.warn(`Failed to connect: Connection pair doesn't exist!`, {
      connectionData,
      entries
    })
    return {
      statusCode: 500,
      body: `Failed to connect: Connection pair doesn't exist!`
    }
  }
  if (entries.length >= 2) {
    log.warn(
      `Failed to connect: A connection pair already exists for this @connId`,
      { connectionData, entries }
    )
    return {
      statusCode: 500,
      body: `Failed to connect: A connection pair already exists for this @connId`
    }
  }

  // Check to ensure that given @signed matches what was originally provided by the initiator //
  let initiator = entries[0]
  if (initiator.role !== roles.initiator) {
    log.warn('Failed to connect: Initiator has disconnected', {
      connectionData,
      entries
    })
    return {
      statusCode: 500,
      body: 'Failed to connect: Initiator has disconnected'
    }
  }
  if (connectionData.query.signed !== initiator.signed) {
    log.warn('Failed to connect: Invalid @signed', { connectionData, entries })
    return { statusCode: 500, body: 'Failed to connect: Invalid @signed' }
  }

  // Create entry with receiver information //
  const putParams = {
    connectionId: connectionData.connectionId,
    connId: connectionData.query.connId,
    role: roles.receiver,
    signed: connectionData.query.signed,
    endpoint:
      connectionData.event.requestContext.domainName +
      '/' +
      connectionData.event.requestContext.stage
  }

  // Perform update //
  try {
    await dynamoDocumentClient.put(putParams)
    log.info('Successfully connected Receiver')
    return { statusCode: 200, body: `Connected` }
  } catch (e) {
    log.warn('Failed to connect Receiver', { e, putParams })
    return { statusCode: 500, body: `Failed to connect: ${JSON.stringify(e)}` }
  }
}

export { handler }
